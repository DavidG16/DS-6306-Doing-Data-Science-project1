breweries_per_state_1
states <- map_data("state")
states
map.df <- merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df <- map.df[order(map.df$order),]
map.df
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=Num.of.Breweries))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)),na.value="grey90")+ggtitle("Breweries by State")
breweries1=breweries
breweries_per_state_1 = breweries_per_state
breweries_per_state_1$State = trimws(breweries_per_state_1$State,which=c("both"),whitespace = "[ ]")
lookup = data.frame(abbr = state.abb, State = state.name)
breweries_per_state_1 = merge(breweries_per_state_1, lookup, by.x="State", by.y="abbr")
breweries_per_state_1$StateLower = tolower(breweries_per_state_1$State.y)
breweries_per_state_1
states <- map_data("state")
states
map.df <- merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df <- map.df[order(map.df$order),]
map.df
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=n))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)),na.value="grey90")+ggtitle("Breweries by State")
coord_map()
breweries1=breweries
breweries_per_state_1 = breweries_per_state
breweries_per_state_1$State = trimws(breweries_per_state_1$State,which=c("both"),whitespace = "[ ]")
lookup = data.frame(abbr = state.abb, State = state.name)
breweries_per_state_1 = merge(breweries_per_state_1, lookup, by.x="State", by.y="abbr")
breweries_per_state_1$StateLower = tolower(breweries_per_state_1$State.y)
breweries_per_state_1
states <- map_data("state")
states
map.df <- merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df <- map.df[order(map.df$order),]
colnames(map.df)[7] = "Num.of.Breweries"
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=Num.of.Breweries))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)),na.value="grey90")+ggtitle("Breweries by State")
breweries1=breweries
breweries_per_state_1 = breweries_per_state
breweries_per_state_1$State = trimws(breweries_per_state_1$State,which=c("both"),whitespace = "[ ]")
lookup = data.frame(abbr = state.abb, State = state.name)
breweries_per_state_1 = merge(breweries_per_state_1, lookup, by.x="State", by.y="abbr")
breweries_per_state_1$StateLower = tolower(breweries_per_state_1$State.y)
breweries_per_state_1
states <- map_data("state")
states
map.df <- merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df <- map.df[order(map.df$order),]
colnames(map.df)[7] = "Num.of.Breweries"
map.df
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=Num.of.Breweries))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)),na.value="grey90")+ggtitle("Breweries by State")
breweries1=breweries
breweries_per_state_1 = breweries_per_state
breweries_per_state_1$State = trimws(breweries_per_state_1$State,which=c("both"),whitespace = "[ ]")
lookup = data.frame(abbr = state.abb, State = state.name)
breweries_per_state_1 = merge(breweries_per_state_1, lookup, by.x="State", by.y="abbr")
breweries_per_state_1$StateLower = tolower(breweries_per_state_1$State.y)
breweries_per_state_1
states <- map_data("state")
states
map.df <- merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df <- map.df[order(map.df$order),]
colnames(map.df)[8] = "Num.of.Breweries"
map.df
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=Num.of.Breweries))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)),na.value="grey90")+ggtitle("Breweries by State")
coord_map()
breweries_per_state_1 = breweries_per_state
breweries_per_state_1$State = trimws(breweries_per_state_1$State,which=c("both"),whitespace = "[ ]")
lookup = data.frame(abbr = state.abb, State = state.name)
breweries_per_state_1 = merge(breweries_per_state_1, lookup, by.x="State", by.y="abbr")
breweries_per_state_1$StateLower = tolower(breweries_per_state_1$State.y)
states <- map_data("state")
map.df <- merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df <- map.df[order(map.df$order),]
colnames(map.df)[8] = "Num.of.Breweries"
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=Num.of.Breweries))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)),na.value="grey90")+ggtitle("Breweries by State")
coord_map()
breweries_per_state_1 = breweries_per_state
breweries_per_state_1$State = trimws(breweries_per_state_1$State,which=c("both"),whitespace = "[ ]")
lookup = data.frame(abbr = state.abb, State = state.name)
breweries_per_state_1 = merge(breweries_per_state_1, lookup, by.x="State", by.y="abbr")
breweries_per_state_1$StateLower = tolower(breweries_per_state_1$State.y)
states <- map_data("state")
map.df <- merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df <- map.df[order(map.df$order),]
colnames(map.df)[8] = "Num.of.Breweries"
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=Num.of.Breweries))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)),na.value="grey90")+ggtitle("Breweries by State")
knitr::opts_chunk$set(echo = TRUE)
library(tm)
library(tidyr)
library(plyr)
library(dplyr)
library(tidyverse)
library(caret)
library(class)
library(e1071)
library(data.table)
breweries = read.csv("./Breweries.csv")
beers = read.csv("./Beers.csv")
breweries_per_state = breweries %>% count(State)
breweries_per_state %>% ggplot() + geom_bar(aes(State, n), fill="blue" ,stat = 'identity') +
labs(x='State', y="Number of Breweries", title='Number of Breweries per State') +
theme(axis.text.x = element_text(angle = 60, hjust = 1))
breweries_per_state_1 = breweries_per_state
breweries_per_state_1$State = trimws(breweries_per_state_1$State,which=c("both"),whitespace = "[ ]")
lookup = data.frame(abbr = state.abb, State = state.name)
breweries_per_state_1 = merge(breweries_per_state_1, lookup, by.x="State", by.y="abbr")
breweries_per_state_1$StateLower = tolower(breweries_per_state_1$State.y)
states <- map_data("state")
map.df <- merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df <- map.df[order(map.df$order),]
colnames(map.df)[8] = "Num.of.Breweries"
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=Num.of.Breweries))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)),na.value="grey90")+ggtitle("Breweries by State")
data = merge(x=breweries, y=beers, by.y ="Brewery_id" , by.x = "Brew_ID")
nrow(data)
head(data,6)
tail(data,6)
missing.values <- data %>%
gather(key = "key", value = "val") %>%
mutate(is.missing = is.na(val)) %>%
group_by(key, is.missing) %>%
summarise(num.missing = n()) %>%
filter(is.missing==T) %>%
select(-is.missing) %>%
arrange(desc(num.missing))
missing.values %>% ggplot() + geom_bar(aes(x=key, y=num.missing), fill="blue",stat = 'identity') +
labs(x='variable', y="number of missing values", title='Number of missing values') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
data %>% ggplot() + geom_histogram(aes(x=ABV), fill="blue") +
labs(x="ABV", y="Count", title="ABV Distribution")
data %>% ggplot() + geom_histogram(aes(x=IBU), fill="blue") +
labs(x="IBU", y="Count", title="IBU Distribution")
# Get rid of special characters in the beer styles
data$Style = gsub("[^0-9A-Za-z' ]"," " , data$Style ,ignore.case = TRUE)
#Deal with NA in IBU
# Finds the median value per beer style
meanIBU = matrix(nrow = 100)
styles = list()
for (i in 1:length(unique(data$Style)) )
{
beer_style = unique(data$Style)[i]
ibu_mean = mean(data[grep(beer_style, data$Style, ignore.case = T),]$IBU,na.rm = T )
meanIBU[i] = ibu_mean
styles[[i]] = beer_style
}
# Create a new styles dataframe with the IBU medians per beer style
styles_impute = data.frame(IBU=meanIBU, Style = matrix(unlist(styles), nrow=length(styles), byrow=T))
# merge the beer styles median IBU dataframe with the working dataframe on style name
impute_data = merge(data, styles_impute, by.x="Style", by.y="Style")
# If NA in original IBU value, then use median IBU per style, else use original value
impute_data = impute_data %>% mutate(imputed_IBU = ifelse(is.na(IBU.x) == TRUE,IBU.y,IBU.x))
# Impute any impute_data value with the median for the ABV and imputed_IBU columns
impute_data= impute_data %>% mutate_at(vars(ABV,imputed_IBU),~ifelse(is.na(.x), median(.x, na.rm = TRUE), .x))
# Get rid of the 5 rows without a beer style.
impute_data = impute_data%>% filter(!Style=="")
# Drop redundant columns
drops =  c("IBU.x","IBU.y")
impute_data = impute_data[ , !(names(impute_data) %in% drops)]
mean_abv_state = aggregate(impute_data[, 8], list(impute_data$State), median)
mean_ibu_state = aggregate(impute_data[, 10], list(impute_data$State), median)
mean_ibu_state %>% ggplot() + geom_bar(aes(Group.1, x),fill="blue", stat = 'identity') +
labs(x='State', y="IBU Value", title='IBU by State') +
theme(axis.text.x = element_text(angle = 60, hjust = 1))
mean_abv_state %>% ggplot() + geom_bar(aes(Group.1, x), fill="blue", stat = 'identity') +
labs(x='State', y="ABV Value", title='ABV by State') +
theme(axis.text.x = element_text(angle = 60, hjust = 1))
impute_data %>% filter(ABV==max(ABV))
impute_data %>% filter(imputed_IBU==max(imputed_IBU))
summary(impute_data$ABV)
impute_data %>% ggplot() + geom_histogram(aes(ABV), fill="blue") +
labs(x='ABV Value', y="count", title='ABV Distribution')
impute_data %>% ggplot() + geom_boxplot(aes(ABV), fill="blue") +
labs(x='ABV Value', y="count", title='ABV Boxplot')
impute_data %>% ggplot() + geom_point(aes(x=ABV, imputed_IBU), color="blue", position="jitter") +
labs(x='ABV Value', y="IBU Value", title="Relation between IBU and ABV")
cor(impute_data$ABV, impute_data$imputed_IBU, method = "spearman")
# Crete new ipa_ale column based on regex from the beer style column
impute_data$ipa_ale = ifelse(grepl("ipa", impute_data$Style, ignore.case = T), "ipa",
ifelse(grepl("ale", impute_data$Style, ignore.case = T), "ale", "Other"))
ale_ipa = impute_data %>% filter(!ipa_ale=="Other")
#vCHoose best K
set.seed(12)
splitPerc = .70
trainIndices = sample(1:dim(ale_ipa)[1],round(splitPerc * dim(ale_ipa)[1]))
train = ale_ipa[trainIndices,]
test = ale_ipa[-trainIndices,]
iterations = 50
accs = data.frame(accuracy = numeric(iterations), k = numeric(iterations))
for(i in 1:iterations)
{
classification = knn(train[,c(8,10)], test[,c(8,10)],train$ipa_ale,k=i)
cm = confusionMatrix(table(test$ipa_ale, classification ), positive="ale")
accs$accuracy[i] = cm$overall[1]
accs$k[i] = i
}
plot(accs$k,accs$accuracy, type = "l", xlab = "k")
axis(side=1, at=c(0:50, 5))
box()
# Run 1000 iterations  on different train/test sets. We will compute the average accuracy, specificity and Sensitivity.
iterations = 1000
masterAcc = matrix(nrow = iterations)
masterSensitivity = matrix(nrow = iterations)
masterSpecificity = matrix(nrow = iterations)
splitPerc = .7 #Training / Test split Percentage
for(j in 1:iterations)
{
splitPerc = .70
set.seed(j*49+15)
trainIndices = sample(1:dim(ale_ipa)[1],round(splitPerc * dim(ale_ipa)[1]))
train = ale_ipa[trainIndices,]
test = ale_ipa[-trainIndices,]
classification = knn(train[,c(8,10)], test[,c(8,10)],train$ipa_ale,k=5)
cm = confusionMatrix(table(test$ipa_ale, classification ), positive="ale")
masterAcc[j] = cm$overall[1]
masterSpecificity[j] = cm$byClass[2]
masterSensitivity[j] = cm$byClass[1]
}
MeanAcc = colMeans(masterAcc)
MeanSpecificity = colMeans(masterSpecificity)
MeanSensitivity = colMeans(masterSensitivity)
MeanAcc
MeanSpecificity
MeanSensitivity
decisionplot <- function(model, data, class = NULL, predict_type = "class",
resolution = 100, showgrid = TRUE, ...) {
if(!is.null(class)) cl <- data[,class] else cl <- 1
data <- data[,1:2]
k <- length(unique(cl))
plot(data, col = as.integer(cl)+1L, pch = as.integer(cl)+1L, ...)
# make grid
r <- sapply(data, range, na.rm = TRUE)
xs <- seq(r[1,1], r[2,1], length.out = resolution)
ys <- seq(r[1,2], r[2,2], length.out = resolution)
g <- cbind(rep(xs, each=resolution), rep(ys, time = resolution))
colnames(g) <- colnames(r)
g <- as.data.frame(g)
### guess how to get class labels from predict
### (unfortunately not very consistent between models)
p <- predict(model, g, type = predict_type)
if(is.list(p)) p <- p$class
p <- as.factor(p)
if(showgrid) points(g, col = as.integer(p)+1L, pch = ".")
z <- matrix(as.integer(p), nrow = resolution, byrow = TRUE)
contour(xs, ys, z, add = TRUE, drawlabels = FALSE,
lwd = 2, levels = (1:(k-1))+.5)
invisible(z)
}
# plot source: https://michael.hahsler.net/SMU/EMIS7332/R/viz_classifier.html
x = ale_ipa[, c(8,10,11)]
x$ipa_ale = as.factor(x$ipa_ale)
model =  knn3(ipa_ale ~ ., data=x, k =5)
decisionplot(model, x, class = "ipa_ale", main = "kNN=5")
#vCHoose best K
set.seed(12)
splitPerc = .70
trainIndices = sample(1:dim(ale_ipa)[1],round(splitPerc * dim(ale_ipa)[1]))
train = ale_ipa[trainIndices,]
test = ale_ipa[-trainIndices,]
iterations = 50
accs = data.frame(accuracy = numeric(iterations), k = numeric(iterations))
for(i in 1:iterations)
{
classification = knn(train[,c(8,10)], test[,c(8,10)],train$ipa_ale,k=i)
cm = confusionMatrix(table(test$ipa_ale, classification ), positive="ale")
accs$accuracy[i] = cm$overall[1]
accs$k[i] = i
}
plot(accs$k,accs$accuracy, type = "l", xlab = "k")
axis(side=1, at=c(0:50, 5))
box()
#vCHoose best K
set.seed(12)
splitPerc = .70
trainIndices = sample(1:dim(ale_ipa)[1],round(splitPerc * dim(ale_ipa)[1]))
train = ale_ipa[trainIndices,]
test = ale_ipa[-trainIndices,]
iterations = 50
accs = data.frame(accuracy = numeric(iterations), k = numeric(iterations))
for(i in 1:iterations)
{
classification = knn(train[,c(8,10)], test[,c(8,10)],train$ipa_ale,k=i)
cm = confusionMatrix(table(test$ipa_ale, classification ), positive="ale")
accs$accuracy[i] = cm$overall[1]
accs$k[i] = i
}
plot(accs$k,accs$accuracy, type = "l", xlab = "k")
axis(side=1, at=c(0:50, 5))
box()
decisionplot <- function(model, data, class = NULL, predict_type = "class",
resolution = 100, showgrid = TRUE, ...) {
if(!is.null(class)) cl <- data[,class] else cl <- 1
data <- data[,1:2]
k <- length(unique(cl))
plot(data, col = as.integer(cl)+1L, pch = as.integer(cl)+1L, ...)
# make grid
r <- sapply(data, range, na.rm = TRUE)
xs <- seq(r[1,1], r[2,1], length.out = resolution)
ys <- seq(r[1,2], r[2,2], length.out = resolution)
g <- cbind(rep(xs, each=resolution), rep(ys, time = resolution))
colnames(g) <- colnames(r)
g <- as.data.frame(g)
### guess how to get class labels from predict
### (unfortunately not very consistent between models)
p <- predict(model, g, type = predict_type)
if(is.list(p)) p <- p$class
p <- as.factor(p)
if(showgrid) points(g, col = as.integer(p)+1L, pch = ".")
z <- matrix(as.integer(p), nrow = resolution, byrow = TRUE)
contour(xs, ys, z, add = TRUE, drawlabels = FALSE,
lwd = 2, levels = (1:(k-1))+.5)
invisible(z)
}
# plot source: https://michael.hahsler.net/SMU/EMIS7332/R/viz_classifier.html
x = ale_ipa[, c(8,10,11)]
x$ipa_ale = as.factor(x$ipa_ale)
model =  knn3(ipa_ale ~ ., data=x, k =5)
decisionplot(model, x, class = "ipa_ale", main = "kNN=5")
breweries_per_state = breweries %>% count(State)
breweries_per_state %>% ggplot() + geom_bar(aes(State, n), fill="blue" ,stat = 'identity') +
labs(x='State', y="Number of Breweries", title='Number of Breweries per State') +
theme(axis.text.x = element_text(angle = 60, hjust = 1))
breweries_per_state
knitr::opts_chunk$set(echo = TRUE)
library(tm)
library(tidyr)
library(plyr)
library(dplyr)
library(tidyverse)
library(caret)
library(class)
library(e1071)
library(data.table)
breweries = read.csv("./Breweries.csv")
beers = read.csv("./Beers.csv")
breweries_per_state = breweries %>% count(State)
breweries_per_state %>% ggplot() + geom_bar(aes(State, n), fill="blue" ,stat = 'identity') +
labs(x='State', y="Number of Breweries", title='Number of Breweries per State') +
theme(axis.text.x = element_text(angle = 60, hjust = 1))
# Building Heatmap of US for number of breweries in each state
breweries_per_state_1 = breweries_per_state
breweries_per_state_1$State = trimws(breweries_per_state_1$State,which=c("both"),whitespace = "[ ]")
lookup = data.frame(abbr = state.abb, State = state.name)
breweries_per_state_1 = merge(breweries_per_state_1, lookup, by.x="State", by.y="abbr")
breweries_per_state_1$StateLower = tolower(breweries_per_state_1$State.y)
states = map_data("state")
map.df = merge(states,breweries_per_state_1, by.x = "region", by.y ="StateLower",  all.x=T)
map.df = map.df[order(map.df$order),]
colnames(map.df)[8] = "Num.of.Breweries"
ggplot(map.df, aes(x=long,y=lat,group=group))+
geom_polygon(aes(fill=Num.of.Breweries))+
geom_path()+
scale_fill_gradientn(colours=rev(heat.colors(5)), na.value="grey90") + ggtitle("Breweries by State")
data = merge(x=breweries, y=beers, by.y ="Brewery_id" , by.x = "Brew_ID")
nrow(data)
head(data,6)
tail(data,6)
missing.values <- data %>%
gather(key = "key", value = "val") %>%
mutate(is.missing = is.na(val)) %>%
group_by(key, is.missing) %>%
summarise(num.missing = n()) %>%
filter(is.missing==T) %>%
select(-is.missing) %>%
arrange(desc(num.missing))
missing.values %>% ggplot() + geom_bar(aes(x=key, y=num.missing), fill="blue",stat = 'identity') +
labs(x='variable', y="number of missing values", title='Number of missing values') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
data %>% ggplot() + geom_histogram(aes(x=ABV), fill="blue") +
labs(x="ABV", y="Count", title="ABV Distribution")
data %>% ggplot() + geom_histogram(aes(x=IBU), fill="blue") +
labs(x="IBU", y="Count", title="IBU Distribution")
# Get rid of special characters in the beer styles
data$Style = gsub("[^0-9A-Za-z' ]"," " , data$Style ,ignore.case = TRUE)
#Deal with NA in IBU
# Finds the median value per beer style
meanIBU = matrix(nrow = 100)
styles = list()
for (i in 1:length(unique(data$Style)) )
{
beer_style = unique(data$Style)[i]
ibu_mean = mean(data[grep(beer_style, data$Style, ignore.case = T),]$IBU,na.rm = T )
meanIBU[i] = ibu_mean
styles[[i]] = beer_style
}
# Create a new styles dataframe with the IBU medians per beer style
styles_impute = data.frame(IBU=meanIBU, Style = matrix(unlist(styles), nrow=length(styles), byrow=T))
# merge the beer styles median IBU dataframe with the working dataframe on style name
impute_data = merge(data, styles_impute, by.x="Style", by.y="Style")
# If NA in original IBU value, then use median IBU per style, else use original value
impute_data = impute_data %>% mutate(imputed_IBU = ifelse(is.na(IBU.x) == TRUE,IBU.y,IBU.x))
# Impute any impute_data value with the median for the ABV and imputed_IBU columns
impute_data= impute_data %>% mutate_at(vars(ABV,imputed_IBU),~ifelse(is.na(.x), median(.x, na.rm = TRUE), .x))
# Get rid of the 5 rows without a beer style.
impute_data = impute_data%>% filter(!Style=="")
# Drop redundant columns
drops =  c("IBU.x","IBU.y")
impute_data = impute_data[ , !(names(impute_data) %in% drops)]
mean_abv_state = aggregate(impute_data[, 8], list(impute_data$State), median)
mean_ibu_state = aggregate(impute_data[, 10], list(impute_data$State), median)
mean_ibu_state %>% ggplot() + geom_bar(aes(Group.1, x),fill="blue", stat = 'identity') +
labs(x='State', y="IBU Value", title='IBU by State') +
theme(axis.text.x = element_text(angle = 60, hjust = 1))
mean_abv_state %>% ggplot() + geom_bar(aes(Group.1, x), fill="blue", stat = 'identity') +
labs(x='State', y="ABV Value", title='ABV by State') +
theme(axis.text.x = element_text(angle = 60, hjust = 1))
impute_data %>% filter(ABV==max(ABV))
impute_data %>% filter(imputed_IBU==max(imputed_IBU))
summary(impute_data$ABV)
impute_data %>% ggplot() + geom_histogram(aes(ABV), fill="blue") +
labs(x='ABV Value', y="count", title='ABV Distribution')
impute_data %>% ggplot() + geom_boxplot(aes(ABV), fill="blue") +
labs(x='ABV Value', y="count", title='ABV Boxplot')
impute_data %>% ggplot() + geom_point(aes(x=ABV, imputed_IBU), color="blue", position="jitter") +
labs(x='ABV Value', y="IBU Value", title="Relation between IBU and ABV")
cor(impute_data$ABV, impute_data$imputed_IBU, method = "spearman")
# Crete new ipa_ale column based on regex from the beer style column
impute_data$ipa_ale = ifelse(grepl("ipa", impute_data$Style, ignore.case = T), "ipa",
ifelse(grepl("ale", impute_data$Style, ignore.case = T), "ale", "Other"))
ale_ipa = impute_data %>% filter(!ipa_ale=="Other")
#Choose the best K
set.seed(12)
splitPerc = .70
trainIndices = sample(1:dim(ale_ipa)[1],round(splitPerc * dim(ale_ipa)[1]))
train = ale_ipa[trainIndices,]
test = ale_ipa[-trainIndices,]
iterations = 50
accs = data.frame(accuracy = numeric(iterations), k = numeric(iterations))
for(i in 1:iterations)
{
classification = knn(train[,c(8,10)], test[,c(8,10)],train$ipa_ale,k=i)
cm = confusionMatrix(table(test$ipa_ale, classification ), positive="ale")
accs$accuracy[i] = cm$overall[1]
accs$k[i] = i
}
plot(accs$k,accs$accuracy, type = "l", xlab = "k")
axis(side=1, at=c(0:50, 5))
box()
# Run 1000 iterations  on different train/test sets. We will compute the average accuracy, specificity and Sensitivity.
iterations = 1000
masterAcc = matrix(nrow = iterations)
masterSensitivity = matrix(nrow = iterations)
masterSpecificity = matrix(nrow = iterations)
splitPerc = .7 #Training / Test split Percentage
for(j in 1:iterations)
{
splitPerc = .70
set.seed(j*49+15)
trainIndices = sample(1:dim(ale_ipa)[1],round(splitPerc * dim(ale_ipa)[1]))
train = ale_ipa[trainIndices,]
test = ale_ipa[-trainIndices,]
classification = knn(train[,c(8,10)], test[,c(8,10)],train$ipa_ale,k=5)
cm = confusionMatrix(table(test$ipa_ale, classification ), positive="ale")
masterAcc[j] = cm$overall[1]
masterSpecificity[j] = cm$byClass[2]
masterSensitivity[j] = cm$byClass[1]
}
MeanAcc = colMeans(masterAcc)
MeanSpecificity = colMeans(masterSpecificity)
MeanSensitivity = colMeans(masterSensitivity)
MeanAcc
MeanSpecificity
MeanSensitivity
decisionplot <- function(model, data, class = NULL, predict_type = "class",
resolution = 100, showgrid = TRUE, ...) {
if(!is.null(class)) cl <- data[,class] else cl <- 1
data <- data[,1:2]
k <- length(unique(cl))
plot(data, col = as.integer(cl)+1L, pch = as.integer(cl)+1L, ...)
# make grid
r <- sapply(data, range, na.rm = TRUE)
xs <- seq(r[1,1], r[2,1], length.out = resolution)
ys <- seq(r[1,2], r[2,2], length.out = resolution)
g <- cbind(rep(xs, each=resolution), rep(ys, time = resolution))
colnames(g) <- colnames(r)
g <- as.data.frame(g)
### guess how to get class labels from predict
### (unfortunately not very consistent between models)
p <- predict(model, g, type = predict_type)
if(is.list(p)) p <- p$class
p <- as.factor(p)
if(showgrid) points(g, col = as.integer(p)+1L, pch = ".")
z <- matrix(as.integer(p), nrow = resolution, byrow = TRUE)
contour(xs, ys, z, add = TRUE, drawlabels = FALSE,
lwd = 2, levels = (1:(k-1))+.5)
invisible(z)
}
# plot source: https://michael.hahsler.net/SMU/EMIS7332/R/viz_classifier.html
x = ale_ipa[, c(8,10,11)]
x$ipa_ale = as.factor(x$ipa_ale)
model =  knn3(ipa_ale ~ ., data=x, k =5)
decisionplot(model, x, class = "ipa_ale", main = "kNN=5")
